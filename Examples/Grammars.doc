
                          GRAMMARS IN LIFE


  NAME 

  gram_translator: an implementation of a translator of extended Definite
                   Clause Grammars in Life. 

  The syntax of the rules, and the method to translate them into life code are
  very close to the usual way to deal with Definite Clause Grammars in Prolog.

  The file gram_translator.lf is loaded by tokenizer.lf, parser.lf, loader.lf,
  shell.lf.

  You can find some examples of grammars in the .gr files. The .in files
  contain queries using the corresponding grammars.


  USAGE

  Basic Syntax:

  - terminals are enclosed in list brackets;
  - non-terminals are represented by ordinary predicate symbols; they can be
    augmented with features, that will play the role of attributes of the
    non-terminal; no feature should be named 0 or 'rest' as those names
    are  used to translate a rule into life code;
  - non-terminals may also be variables, provided that they eventually get
    instantiated to a predicate symbol or a list;
  - the left and right-hand side of a rule are separated by the symbol '-->';
  - symbols in the right-hand side of the rule are separated  by commas ;
  - rules end with a question mark; They may end with a dot if the loader in
    Life is used, or the shell in Life. 
  - the empty string is denoted by the empty list.
  - standard Life code may be inserted using #( code ).


  Customization:

  The default structure for the input of the grammar is a list. This may be
  changed by modifying the 'C' function. You may modify this function, using:
      set_C(my_C) ?
  and defining my_C your own way. 'C' is only used during the expansion of your
  grammar in Life clauses, so you can reset its value to the default after
  translation (typing reset_C ?)

  Warning: if you use something else than lists to represent the non-terminals
  that have to be recognised, you should also modify varSymbol.


  FILES

  The gram_translator.lf file contains the implementation of a translator of 
  extended Definite Clause Grammars in Life.
                                                                             
  The file utils.lf contains utilities used by the translator; it is 
  automatically loaded if it is in the same directory. 
                 

  DESCRIPTION

  1- TRANSLATION INTO LIFE

  Rules are translated into life clauses using difference lists.

  ex: 
  a --> b, [foo], c ?

  is translated into:

  a(0 => _A,rest => _B) :-
        b(0 => _A,rest => [foo|_C:@]),
        c(0 => _C,rest => _B).

  
  The 0 and 'rest' features added to every non-terminal are a difference list
  representing a sequence of words that derives from the non-terminal in 
  the  language described by the grammar. In Life, it is necessary to give them
  explicit names, as symbols are not of fixed arity. 0 has been chosen for
  efficiency reasons: the feature containing the tokens is very often used to
  discriminate between rules, and thus should be unified as soon as possible;
  If there is no "negative" feature, the 0 feature is unified first.


  2- VARIABLES AS SYMBOLS

  Variables may be used as symbols in the body of the rules:

  ex:
  a(X) --> X ?
  
  is translated into

  a(0 => _A,_B,rest => _C) :-
        varSymbol(0 => _A,_B,c_name => default_C,rest => _C).

  This way, if X is instantiated to some symbol foo, the first rule will behave
  exactly like:
  a --> foo ?
  If X is instantiated to [1,2,3], it will behave like:
  a --> [1,2,3] ?

  The c_name feature is the name of the 'C' function used when the grammar
  is being translated to Life.

  3- USE OF DISJUNCTIONS

  Disjunctions may be used within grammar rules exactly in the same way as in
  pure life code:

  ex: 
  a --> ( b ; c ) , d ?

  is tranlated into:

  a(rest => _A,0 => _B) :-
	(b(rest => _C,0 => _B) ; c(rest => _C,0 => _B)),
	d(rest => _A,0 => _C).


  4- INSERTION OF LIFE CODE

  The body of a rule may contain terms of the form #(Life_code) where Life_code
  is a piece of code that will be inserted as is in the corresponding clause.
  In future versions, this will be replaced by { Life_code }, using standard
  DCG notation. 


  ex:
  expr(Z) --> term(X), [+], expr(Y) , #( Z = X+Y ) ?

  is tranlated into:

  expr(Z,rest => _B,0 => _C) :-
	term(X,rest => [+|_E:@],0 => _C),
	expr(Y,rest => _B,0 => _E),
	Z = X + Y.


  5- INSERTION OF CUTS

  Cuts may be used: '!' is syntactic sugar for '#(!)'.

  ex:
  a --> b, !, c ?

  is tranlated into:

  a(rest => _A,0 => _B) :-
	b(rest => _C,0 => _B),
	!,
	c(rest => _A,0 => _C).


  6- EXAMPLE

  In his paper introducing attribute grammars, D.E. Knuth gave the example of a
  grammar that could recognise floating binary numbers, and compute their
  decimal value. We give here a first version of this grammar:

  The feature 'value' represents the decimal value of the sequence derived from
                                        a symbol;
	      'length'	             length of a sequence of numbers;
	      'rank'                 rank of a bit in a sequence.


  z( value => V) --> l( value => V) ?
  z( value => V1+V2*2^(-L)) --> 	
  	l( value => V1), 
	["."], 
	l( value => V2, length => L) ?
    
  l( value => V3+V4, length => L1+1) --> 	
	b( value => V3, rank => L1),
	l( value => V4, length => L1) ?
  l( value => V5, length => 1) -->  	
	b( value => V5, rank => 0) ?
    
  b( value => (2^Sv), rank => Sv) --> [1] ? 
  b( value => 0) --> [0] ?



  To the query:
  z( 0 => [1,1,0,1,1,0,1,0,1,1,".",1,1,1,0,1,0,1], 
	rest => [], value => V)?
    
  wild_life answers: V = 875.914.
  In fact, this version is very naive, and may be improved as follows:


  z( value => V) --> 
	l( value => V1),
	( ["."], !, l( value => V2, length => L),
	#( V = V1+V2*2^(-L)) ;
	#( V = V1) 
    ) ?


  l( value => V, length => L)	-->  	
	b( value => V1, rank => S1),
	( l( value => V2, length => L2), !,
	# ( S1 = L2, V = V1+V2, L = L2+1) ;
	# ( S1 = 0, V = V1, L = 1)
    ) ?


  b( rank => Sv, value => V) -->
	( [1], !, #( X = 1, V = 2^Sv);
	    [0], #( X = 0, V = 0) ) ?
	
	
  The answer is of course the same, but this version runs about five times
  faster than the previous one, and there is no useless choice-point left.
  There are several reasons why this version runs much faster:

  - use of cuts to prune the search tree;
  - use of disjunctions to avoid redundant computation;
  - computation of the numeric expressions once the values are known: very few
    expressions residuate in the second version, whereas almost all of them do 
    in the first version. 



  7- FREQUENT ERRORS

  Omit [] around terminals
  Omit #( ) around Life code
  Omit rest => [] in the query: in some cases this has no influence on the
  result, but omitting this means that you accept to parse a part of the
  entry, and not the totality: the query may succeed with a non-empty rest.



  8- IMPLEMENTATION NOTES

  a- Insertion of Life Code:

  There are two ways of translating a rule like:
  foo --> #(pred) ?

  Either:
  foo(rest => _A,0 => _B) :-
	pred,
	_A = _B.
  or:
  foo(rest => _A,0 => _A) :-
	pred.

  In most cases, those two translations will have exactly the same behaviour,
  but if some side-effect is expected from pred, they may differ. It is the
  case if pred is a cut for instance. 
  The translation used here is the second one, namely 'foo -->  #(pred) ?' is
  equivalent to  'foo --> [], #(pred) ?'. 
  The second possibility may be obtained by writing : foo -->  #(pred), []  ?


  b- Folding of terminals.

  A translation of : foo --> bar, [1] ? could be:
  foo(rest => _A,0 => _B) :-
	bar(rest => _C,0 => _B),
	_C = [1,_A].

  The last statement may be folded into the bar predicate, yielding:
  foo(rest => _A,0 => _B) :-
	bar(rest => [1|_A],0 => _B).

  This translation is more efficient than the previous one, and the meaning of
  the two clauses are identical, as long as the bar predicate does not contain
  things like destructive assignments on its rest feature.

  When code is inserted - for instance a cut - we have to make sure that this
  folding does not bind variables occuring before the insertion: If we consider
  foo --> !, [1] ?

  this first translation (with folding):
  foo(rest => _A,0 => [1|_A]) :-
	!.   

  has not the same behaviour as  this one (without folding):
  foo(rest => _A,0 => _B) :-
	!,
	_B = [1|_A].

  The first translation is not correct w.r.t. the usual meaning of cut. The
  translator we propose here deals with this in a very simple way: no folding
  is performed after a cut or a code insertion. This rule could certainly be
  improved by a more accurate analysis of the variables. FoldOk is the variable
  used in the translator to decide whether folding is authorized or not .

  If some side-effect is expected inside a non-terminal, it is still possible
  to obtain a translation where no folding is performed: 
  foo --> bar, #, [1] ?

  will be translated into 
  foo(rest => _A,0 => _B) :-
	bar,
	_A = _B.

  '#' has the same meaning as '[]', except that no folding is performed after
  this symbol. 


  Folding is not performed either whithin disjunctions. Otherwise, it would not
  even be possible to tranlate rules like:

  foo --> ( [1] ; [2] ) ?

  as the rest of foo would be bound to [1|_A] and [2|_B], which are not
  unifiable. InDisj is the variable used in the translator to decide whether
  the term translated occurs inside a disjunction or not.

  The function responsible for the translation of terminals is named 'C' (like
  in many Prolog systems). It has four arguments:

  Terms  : the structure representing the non-terminals to be recognised;
  Xs     : the input stream of non-terminals;
  Ys     : the output stream of non-terminals
  FoldOk : a boolean telling whether Terms may be folded into the program or
           not. 

  It may be customized, as shown above.


  AUTHOR 

  Bruno Dumant

  Copyright 1992 Digital Equipment Corporation
  All Rights Reserved




